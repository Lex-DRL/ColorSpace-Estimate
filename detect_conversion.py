#!/usr/bin/env python
# encoding: utf-8

"""
Generated by DeepSeek - to detect coefficients for a function, which:
- has two branches, chosen by cutoff/breakpoint
- each branch has first linear transform -> pow - > second linear transform.

Negligible coefficients can be removed later (i.e., linear transform with: `x * 0.(9) + 0.(0)1`).
"""

import json
import numpy as np
from scipy.optimize import curve_fit

# Load the JSON data
with open('conversion.json', 'r') as file:
	data = json.load(file)

# Extract all input and output values (flattened)
x_data = []
y_data = []
for entry in data:
	a = entry['a']
	f_a = entry['f_a']
	for i in range(3):
		x_data.append(a[i])
		y_data.append(f_a[i])

x_data = np.array(x_data)
y_data = np.array(y_data)

def generalized_piecewise_model(
	x, cutoff,
	A1_low, B1_low, p_low, A2_low, B2_low,
	A1_high, B1_high, p_high, A2_high, B2_high
):
	"""
	Generalized piecewise function with different transformations below and above cutoff:
	- For x <= cutoff: f(x) = A2_low * (A1_low * x + B1_low)^p_low + B2_low
	- For x > cutoff: f(x) = A2_high * (A1_high * x + B1_high)^p_high + B2_high
	"""
	result = np.zeros_like(x)
	low_mask = x <= cutoff
	high_mask = x > cutoff
	
	# Apply low-range transformation
	result[low_mask] = A2_low * np.power(A1_low * x[low_mask] + B1_low, p_low) + B2_low
	
	# Apply high-range transformation
	result[high_mask] = A2_high * np.power(A1_high * x[high_mask] + B1_high, p_high) + B2_high
	
	return result

# Set initial guesses based on sRGB parameters
initial_guess = [
	0.0031308,  # cutoff
	1.0, 0.0, 1.0, 12.92, 0.0,  # A1_low, B1_low, p_low, A2_low, B2_low
	1.0, 0.0, 1/2.4, 1.055, -0.055  # A1_high, B1_high, p_high, A2_high, B2_high
]

# Set bounds to ensure numerical stability
bounds = (
	[0.0001,  # cutoff lower bound
	 0.5, -0.1, 0.8, 10, -0.1,  # low range bounds
	 0.5, -0.1, 0.3, 0.5, -0.1],  # high range bounds
	[0.01,  # cutoff upper bound
	 2.0, 0.1, 1.2, 15, 0.1,  # low range bounds
	 2.0, 0.1, 0.5, 2.0, 0.0]   # high range bounds
)

try:
	# Perform curve fitting
	params, covariance = curve_fit(
		generalized_piecewise_model, x_data, y_data, p0=initial_guess, bounds=bounds, maxfev=10000
	)
	
	# Extract the parameters
	cutoff = params[0]
	A1_low, B1_low, p_low, A2_low, B2_low = params[1:6]
	A1_high, B1_high, p_high, A2_high, B2_high = params[6:]
	
	print("Fitted parameters:")
	print(f"Cutoff: {cutoff}")
	print("\nLow range (x <= cutoff):")
	print(f"A1_low = {A1_low}")
	print(f"B1_low = {B1_low}")
	print(f"p_low = {p_low}")
	print(f"A2_low = {A2_low}")
	print(f"B2_low = {B2_low}")
	print("\nHigh range (x > cutoff):")
	print(f"A1_high = {A1_high}")
	print(f"B1_high = {B1_high}")
	print(f"p_high = {p_high}")
	print(f"A2_high = {A2_high}")
	print(f"B2_high = {B2_high}")
	
	# Calculate errors
	y_pred = generalized_piecewise_model(x_data, *params)
	rmse = np.sqrt(np.mean((y_pred - y_data)**2))
	max_error = np.max(np.abs(y_pred - y_data))
	print(f"\nRoot Mean Square Error (RMSE): {rmse}")
	print(f"Maximum Absolute Error: {max_error}")
	
	# Check if the cutoff is meaningful
	low_points = np.sum(x_data <= cutoff)
	print(f"Number of points below cutoff: {low_points}/{len(x_data)}")
	
	# Check if parameters are close to special values that could be simplified
	print("\nSimplification suggestions:")
	if abs(p_low - 1.0) < 0.01:
		print("- Low range appears linear (p_low ≈ 1)")
	if abs(B1_low) < 0.01:
		print("- Low range pre-transform has negligible offset (B1_low ≈ 0)")
	if abs(B2_low) < 0.01:
		print("- Low range post-transform has negligible offset (B2_low ≈ 0)")
	
	if abs(B1_high) < 0.01:
		print("- High range pre-transform has negligible offset (B1_high ≈ 0)")
	if abs(B2_high) < 0.01:
		print("- High range post-transform has negligible offset (B2_high ≈ 0)")
		
except Exception as e:
	print(f"Fitting failed: {e}")
	print("This might be due to the complexity of the model or the data.")
	
	# Fallback: try a simpler model with fixed p_low = 1 (linear low range)
	print("\nTrying simplified model with linear low range...")
	
	def simplified_model(
		x, cutoff,
		A_low, B_low,
		A1_high, B1_high, p_high, A2_high, B2_high
	):
		result = np.zeros_like(x)
		low_mask = x <= cutoff
		high_mask = x > cutoff
		
		# Linear transformation for low range
		result[low_mask] = A_low * x[low_mask] + B_low
		
		# Power transformation for high range
		result[high_mask] = A2_high * np.power(A1_high * x[high_mask] + B1_high, p_high) + B2_high
		
		return result
	
	simplified_guess = [
		0.0031308,  # cutoff
		12.92, 0.0,  # A_low, B_low
		1.0, 0.0, 1/2.4, 1.055, -0.055  # High range parameters
	]
	
	simplified_bounds = (
		[0.0001, 10, -0.1, 0.5, -0.1, 0.3, 0.5, -0.1],
		[0.01, 15, 0.1, 2.0, 0.1, 0.5, 2.0, 0.0]
	)
	
	try:
		params, covariance = curve_fit(
			simplified_model, x_data, y_data, p0=simplified_guess, bounds=simplified_bounds, maxfev=10000
		)
		
		cutoff, A_low, B_low, A1_high, B1_high, p_high, A2_high, B2_high = params
		
		print("Fitted parameters for simplified model:")
		print(f"Cutoff: {cutoff}")
		print(f"Low range (linear): f(x) = {A_low} * x + {B_low}")
		print(f"High range: f(x) = {A2_high} * ({A1_high} * x + {B1_high})^{p_high} + {B2_high}")
		
		# Calculate errors
		y_pred = simplified_model(x_data, *params)
		rmse = np.sqrt(np.mean((y_pred - y_data)**2))
		max_error = np.max(np.abs(y_pred - y_data))
		print(f"Root Mean Square Error (RMSE): {rmse}")
		print(f"Maximum Absolute Error: {max_error}")
		
	except Exception as e2:
		print(f"Simplified fitting also failed: {e2}")
